name: Test Git Signatures

on:
  push:
    branches:
      - '**'
  pull_request:
    types: [opened, reopened, synchronize]

# Minimal permissions - only read access needed for checks
permissions:
  contents: read

jobs:
  test-git-signatures:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history to compare with main

      - name: Check commit signatures
        id: signature-check
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');

            // Get current branch name
            const currentBranch = process.env.GITHUB_REF_NAME;
            console.log(`Current branch: ${currentBranch}`);

            // Skip signature check on main branch to avoid failing on historical unsigned commits
            if (currentBranch === 'main') {
              console.log('On main branch - skipping signature check for historical commits.');
              console.log('Signature verification only runs on PR branches.');
              return;
            }

            // Get commits that are on this branch but not on origin/main
            let commitShas;
            try {
              const output = execSync('git rev-list origin/main..HEAD', { encoding: 'utf-8' });
              commitShas = output.trim().split('\n').filter(sha => sha.length > 0);
            } catch (error) {
              console.log('Could not compare with origin/main, checking all commits on this branch.');
              // Fallback: just check the current commit
              commitShas = [process.env.GITHUB_SHA];
            }

            if (commitShas.length === 0) {
              console.log('No new commits to check (branch is up to date with main).');
              return;
            }

            console.log(`Checking ${commitShas.length} commit(s) via GitHub API...`);

            // Check each commit's verification status via GitHub API
            const unsignedCommits = [];

            for (const sha of commitShas) {
              try {
                const commit = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha
                });

                const verification = commit.data.commit.verification;
                const shortSha = sha.substring(0, 7);
                const message = commit.data.commit.message.split('\n')[0];

                if (verification && verification.verified) {
                  console.log(`✓ ${shortSha} - ${message} (${verification.reason})`);
                } else {
                  const reason = verification ? verification.reason : 'unknown';
                  console.log(`✗ ${shortSha} - ${message} (${reason})`);
                  unsignedCommits.push({
                    sha: shortSha,
                    fullSha: sha,
                    message: message,
                    reason: reason
                  });
                }
              } catch (error) {
                console.log(`⚠ ${sha.substring(0, 7)} - Could not verify (${error.message})`);
                // Don't fail on API errors for individual commits
              }
            }

            if (unsignedCommits.length > 0) {
              // Set outputs for PR comment workflow
              core.setOutput('unsigned_count', unsignedCommits.length);
              core.setOutput('unsigned_commits', unsignedCommits.map(c => `- \`${c.sha}\`: ${c.message} (${c.reason})`).join('\n'));

              console.log('\n❌ Found unsigned commits:');
              for (const commit of unsignedCommits) {
                console.log(`   ${commit.sha}: ${commit.message} (reason: ${commit.reason})`);
              }
              console.log('\nAll commits must be signed. See the PR comments for instructions on how to sign commits.');
              console.log('You can re-sign commits with: git rebase -i HEAD~N --exec "git commit --amend --no-edit -S"');
              core.setFailed(`${unsignedCommits.length} unsigned commit(s) found. All commits must be signed.`);
            } else {
              console.log(`\n✅ All ${commitShas.length} commit(s) are properly signed.`);
            }

      - name: Save PR number and result
        if: always() && github.event_name == 'pull_request'
        run: |
          mkdir -p ./pr-comment-data
          echo '${{ github.event.pull_request.number }}' > ./pr-comment-data/pr_number
          echo '${{ steps.signature-check.outcome }}' > ./pr-comment-data/outcome
          echo '${{ steps.signature-check.outputs.unsigned_count }}' > ./pr-comment-data/unsigned_count
          cat << 'EOF' > ./pr-comment-data/unsigned_commits
          ${{ steps.signature-check.outputs.unsigned_commits }}
          EOF

      - name: Upload PR comment data
        if: always() && github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: pr-comment-data
          path: pr-comment-data/
          retention-days: 1
